---
// Physics Background Component using Matter.js
---

<div id="physics-canvas-container" class="fixed top-0 left-0 w-full h-full pointer-events-none z-0 opacity-30">
	<canvas id="physics-canvas"></canvas>
</div>

<script>
	import Matter from 'matter-js';

	// Wait for DOM to be ready
	if (typeof window !== 'undefined') {
		const initPhysics = () => {
			const canvas = document.getElementById('physics-canvas');
			const container = document.getElementById('physics-canvas-container');

			if (!canvas || !container) return;

			// Module aliases
			const Engine = Matter.Engine,
				Render = Matter.Render,
				Runner = Matter.Runner,
				Bodies = Matter.Bodies,
				Composite = Matter.Composite,
				Mouse = Matter.Mouse,
				MouseConstraint = Matter.MouseConstraint,
				Events = Matter.Events;

			// Create engine
			const engine = Engine.create({
				gravity: { x: 0, y: 0.05 }
			});

			// Create renderer
			const render = Render.create({
				canvas: canvas,
				engine: engine,
				options: {
					width: window.innerWidth,
					height: window.innerHeight,
					wireframes: false,
					background: 'transparent'
				}
			});

			// Create geometric shapes with futuristic colors and glow effects
			const colors = [
				{ fill: '#6366f1', glow: 'rgba(99, 102, 241, 0.6)' }, // indigo
				{ fill: '#8b5cf6', glow: 'rgba(139, 92, 246, 0.6)' }, // violet
				{ fill: '#06b6d4', glow: 'rgba(6, 182, 212, 0.6)' }, // cyan
				{ fill: '#10b981', glow: 'rgba(16, 185, 129, 0.6)' }, // emerald
				{ fill: '#f59e0b', glow: 'rgba(245, 158, 11, 0.6)' }, // amber
				{ fill: '#ec4899', glow: 'rgba(236, 72, 153, 0.6)' }, // pink
				{ fill: '#3b82f6', glow: 'rgba(59, 130, 246, 0.6)' }, // blue
			];

			const shapes: Matter.Body[] = [];

			// Create more circles with varied sizes
			for (let i = 0; i < 12; i++) {
				const size = Math.random() * 40 + 15;
				const colorObj = colors[Math.floor(Math.random() * colors.length)];
				shapes.push(
					Bodies.circle(
						Math.random() * window.innerWidth,
						Math.random() * window.innerHeight,
						size,
						{
							render: {
								fillStyle: colorObj.fill,
								strokeStyle: colorObj.glow,
								lineWidth: 3,
								shadowBlur: 15,
								shadowColor: colorObj.glow
							},
							restitution: 0.9,
							friction: 0.001,
							density: 0.0008,
							frictionAir: 0.001
						}
					)
				);
			}

			// Create rectangles with rotation
			for (let i = 0; i < 8; i++) {
				const width = Math.random() * 50 + 25;
				const height = Math.random() * 50 + 25;
				const colorObj = colors[Math.floor(Math.random() * colors.length)];
				shapes.push(
					Bodies.rectangle(
						Math.random() * window.innerWidth,
						Math.random() * window.innerHeight,
						width,
						height,
						{
							render: {
								fillStyle: colorObj.fill,
								strokeStyle: colorObj.glow,
								lineWidth: 3,
								shadowBlur: 15,
								shadowColor: colorObj.glow
							},
							restitution: 0.85,
							friction: 0.001,
							density: 0.0008,
							frictionAir: 0.001,
							angle: Math.random() * Math.PI * 2
						}
					)
				);
			}

			// Create polygons (triangles, pentagons, hexagons, octagons)
			for (let i = 0; i < 10; i++) {
				const sides = Math.floor(Math.random() * 6) + 3; // 3-8 sides
				const radius = Math.random() * 30 + 15;
				const colorObj = colors[Math.floor(Math.random() * colors.length)];
				shapes.push(
					Bodies.polygon(
						Math.random() * window.innerWidth,
						Math.random() * window.innerHeight,
						sides,
						radius,
						{
							render: {
								fillStyle: colorObj.fill,
								strokeStyle: colorObj.glow,
								lineWidth: 3,
								shadowBlur: 15,
								shadowColor: colorObj.glow
							},
							restitution: 0.9,
							friction: 0.001,
							density: 0.0008,
							frictionAir: 0.001,
							angle: Math.random() * Math.PI * 2
						}
					)
				);
			}

			// Create boundaries (invisible walls)
			const wallThickness = 50;
			const walls = [
				// top
				Bodies.rectangle(window.innerWidth / 2, -wallThickness / 2, window.innerWidth, wallThickness, {
					isStatic: true,
					render: { visible: false }
				}),
				// bottom
				Bodies.rectangle(window.innerWidth / 2, window.innerHeight + wallThickness / 2, window.innerWidth, wallThickness, {
					isStatic: true,
					render: { visible: false }
				}),
				// left
				Bodies.rectangle(-wallThickness / 2, window.innerHeight / 2, wallThickness, window.innerHeight, {
					isStatic: true,
					render: { visible: false }
				}),
				// right
				Bodies.rectangle(window.innerWidth + wallThickness / 2, window.innerHeight / 2, wallThickness, window.innerHeight, {
					isStatic: true,
					render: { visible: false }
				})
			];

			// Add all bodies to the world
			Composite.add(engine.world, [...shapes, ...walls]);

			// Add mouse control with repulsion effect
			const mouse = Mouse.create(render.canvas);
			const mouseConstraint = MouseConstraint.create(engine, {
				mouse: mouse,
				constraint: {
					stiffness: 0.2,
					render: { visible: false }
				}
			});

			Composite.add(engine.world, mouseConstraint);

			// Keep the mouse in sync with rendering
			render.mouse = mouse;

			// Add interactive forces and flowing motion
			Events.on(engine, 'beforeUpdate', () => {
				shapes.forEach((shape, index) => {
					// Apply flowing forces to create organic movement
					if (Math.random() < 0.03) {
						const forceMagnitude = 0.00015;
						const angle = (Date.now() / 1000 + index) * 0.5;
						Matter.Body.applyForce(shape, shape.position, {
							x: Math.cos(angle) * forceMagnitude,
							y: Math.sin(angle) * forceMagnitude
						});
					}

					// Add gentle rotation for visual interest
					const targetAngularVelocity = (Math.sin(Date.now() / 2000 + index) * 0.01);
					Matter.Body.setAngularVelocity(shape, shape.angularVelocity * 0.98 + targetAngularVelocity * 0.02);

					// Create attractive/repulsive forces between nearby shapes
					shapes.forEach((otherShape, otherIndex) => {
						if (index !== otherIndex) {
							const dx = otherShape.position.x - shape.position.x;
							const dy = otherShape.position.y - shape.position.y;
							const distance = Math.sqrt(dx * dx + dy * dy);

							if (distance < 200 && distance > 0) {
								// Gentle repulsion when very close
								const forceMagnitude = 0.00001 / (distance * distance);
								Matter.Body.applyForce(shape, shape.position, {
									x: -dx * forceMagnitude,
									y: -dy * forceMagnitude
								});
							}
						}
					});

					// Keep shapes within viewport with gentle boundary forces
					const margin = 100;
					if (shape.position.x < margin) {
						Matter.Body.applyForce(shape, shape.position, { x: 0.0001, y: 0 });
					}
					if (shape.position.x > window.innerWidth - margin) {
						Matter.Body.applyForce(shape, shape.position, { x: -0.0001, y: 0 });
					}
					if (shape.position.y < margin) {
						Matter.Body.applyForce(shape, shape.position, { x: 0, y: 0.0001 });
					}
					if (shape.position.y > window.innerHeight - margin) {
						Matter.Body.applyForce(shape, shape.position, { x: 0, y: -0.0001 });
					}
				});
			});

			// Run the renderer
			Render.run(render);

			// Create runner
			const runner = Runner.create();
			Runner.run(runner, engine);

			// Handle window resize
			const handleResize = () => {
				render.canvas.width = window.innerWidth;
				render.canvas.height = window.innerHeight;
				render.options.width = window.innerWidth;
				render.options.height = window.innerHeight;

				// Update wall positions
				Matter.Body.setPosition(walls[0], { x: window.innerWidth / 2, y: -wallThickness / 2 });
				Matter.Body.setPosition(walls[1], { x: window.innerWidth / 2, y: window.innerHeight + wallThickness / 2 });
				Matter.Body.setPosition(walls[2], { x: -wallThickness / 2, y: window.innerHeight / 2 });
				Matter.Body.setPosition(walls[3], { x: window.innerWidth + wallThickness / 2, y: window.innerHeight / 2 });

				// Update wall dimensions
				Matter.Body.set(walls[0], { vertices: Matter.Vertices.fromPath(`0 0 ${window.innerWidth} 0 ${window.innerWidth} ${wallThickness} 0 ${wallThickness}`) });
				Matter.Body.set(walls[1], { vertices: Matter.Vertices.fromPath(`0 0 ${window.innerWidth} 0 ${window.innerWidth} ${wallThickness} 0 ${wallThickness}`) });
			};

			window.addEventListener('resize', handleResize);

			// Cleanup on page navigation
			document.addEventListener('astro:before-preparation', () => {
				window.removeEventListener('resize', handleResize);
				Render.stop(render);
				Runner.stop(runner);
				Engine.clear(engine);
			});
		};

		// Initialize on page load
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initPhysics);
		} else {
			initPhysics();
		}

		// Re-initialize on page navigation
		document.addEventListener('astro:page-load', initPhysics);
	}
</script>

<style>
	#physics-canvas-container {
		mix-blend-mode: screen;
	}

	@media (prefers-reduced-motion: reduce) {
		#physics-canvas-container {
			display: none;
		}
	}
</style>
